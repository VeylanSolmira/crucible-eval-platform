# =============================================================================
# Frontend Container - React Dashboard with Nginx
# Purpose: Serve static React app with optimal performance and security
# Architecture: Multi-stage build (Node.js build â†’ Nginx serve)
# =============================================================================

# =============================================================================
# STAGE 1: Build Stage - Node.js Environment
# Purpose: Compile TypeScript, bundle React, optimize assets
# Base: Node 18 on Alpine (small, secure, fast)
# =============================================================================
FROM node:18-alpine as builder

# Install additional build tools that some npm packages might need
# python3, make, g++: Required for node-gyp (native module compilation)
# git: For packages installed from git repositories
RUN apk add --no-cache python3 make g++ git

# Set working directory for build
WORKDIR /app

# Copy package files first (Docker layer caching optimization)
# If dependencies don't change, this layer is cached even if source changes
COPY frontend/package*.json ./

# Install dependencies with specific flags:
# --frozen-lockfile: Ensures reproducible installs (like --pure-lockfile)
# npm ci is faster and more reliable than npm install for CI/CD
RUN npm ci --frozen-lockfile

# Copy TypeScript config and source files
# Separate COPY commands for better caching granularity
COPY frontend/tsconfig.json ./
COPY frontend/public/ ./public/
COPY frontend/src/ ./src/

# Build the React application
# This runs webpack to:
# - Transpile TypeScript to JavaScript
# - Bundle all modules
# - Minify code
# - Generate source maps
# - Optimize images
# - Create production build in ./build/
RUN npm run build

# Optional: Run linting and type checking
# Uncomment for CI/CD pipeline to catch issues early
# RUN npm run lint && npm run type-check

# =============================================================================
# STAGE 2: Runtime Stage - Nginx Web Server
# Purpose: Serve static files with high performance
# Base: Nginx Alpine (production-grade web server, ~40MB total)
# =============================================================================
FROM nginx:1.24-alpine

# Install runtime dependencies
# curl: For health checks
# tzdata: For timezone support
RUN apk add --no-cache curl tzdata

# Create non-root user for nginx
# Note: nginx master process still runs as root (required for port binding)
# but worker processes run as this user
RUN adduser -D -H -u 1002 -s /sbin/nologin nginx-user

# Copy built React app from builder stage
# /usr/share/nginx/html is the default nginx static file directory
COPY --from=builder /app/build /usr/share/nginx/html

# Copy custom nginx configuration
# This includes security headers, caching rules, and SPA routing
COPY docker/nginx.conf /etc/nginx/nginx.conf
COPY docker/default.conf /etc/nginx/conf.d/default.conf

# Create necessary directories and set permissions
# /var/cache/nginx: For proxy cache
# /var/run: For nginx pid file
RUN mkdir -p /var/cache/nginx /var/run && \
    chown -R nginx-user:nginx-user /var/cache/nginx && \
    chown -R nginx-user:nginx-user /var/run

# Security: Remove default nginx pages
RUN rm -rf /usr/share/nginx/html/index.html /usr/share/nginx/html/50x.html

# Expose port 80 (documentation only)
# Note: In production, you'd typically use 8080 for non-root
EXPOSE 80

# Health check to ensure nginx is responding
# Checks the React app's index.html to ensure files are served correctly
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost/index.html || exit 1

# Run nginx in foreground (required for Docker)
# -g "daemon off;": Prevents nginx from daemonizing
CMD ["nginx", "-g", "daemon off;"]