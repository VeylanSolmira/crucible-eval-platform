name: Deploy to AWS

on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual trigger

env:
  AWS_REGION: us-west-2

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Get deployment bucket name
      id: bucket
      run: |
        # Get bucket name from Terraform outputs
        BUCKET_NAME=$(aws s3 ls | grep crucible-deployment | awk '{print $3}' | head -1)
        if [ -z "$BUCKET_NAME" ]; then
          echo "âŒ No deployment bucket found. Run terraform apply first."
          exit 1
        fi
        echo "bucket_name=$BUCKET_NAME" >> $GITHUB_OUTPUT

    - name: Build deployment package
      run: |
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        PACKAGE_NAME="crucible-platform-${TIMESTAMP}.tar.gz"
        
        tar -czf "${PACKAGE_NAME}" \
          --exclude='.git' \
          --exclude='__pycache__' \
          --exclude='*.pyc' \
          --exclude='.env' \
          --exclude='venv' \
          --exclude='.pytest_cache' \
          --exclude='infrastructure' \
          --exclude='docs' \
          .
        
        echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV

    - name: Upload to S3
      run: |
        aws s3 cp "${PACKAGE_NAME}" "s3://${{ steps.bucket.outputs.bucket_name }}/${PACKAGE_NAME}"
        aws s3 cp "${PACKAGE_NAME}" "s3://${{ steps.bucket.outputs.bucket_name }}/latest.tar.gz"

    - name: Get EC2 instance ID
      id: ec2
      run: |
        INSTANCE_ID=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=crucible-eval-server" \
          --query "Reservations[0].Instances[0].InstanceId" \
          --output text)
        echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT

    - name: Update EC2 instance
      run: |
        # Update instance using Systems Manager
        aws ssm send-command \
          --instance-ids "${{ steps.ec2.outputs.instance_id }}" \
          --document-name "AWS-RunShellScript" \
          --parameters 'commands=[
            "cd /home/ubuntu",
            "aws s3 cp s3://${{ steps.bucket.outputs.bucket_name }}/latest.tar.gz crucible-latest.tar.gz",
            "rm -rf crucible-new && mkdir crucible-new",
            "tar -xzf crucible-latest.tar.gz -C crucible-new",
            "[ -d crucible ] && mv crucible crucible-old",
            "mv crucible-new crucible",
            "cd crucible",
            "# Ensure directories exist with correct permissions",
            "mkdir -p storage /var/log/crucible",
            "sudo chown -R ubuntu:ubuntu storage /var/log/crucible",
            "# Setup/update virtual environment",
            "if [ ! -d venv ]; then python3.11 -m venv venv; fi",
            "./venv/bin/pip install --upgrade pip",
            "# Install dependencies",
            "if [ -f requirements.txt ]; then ./venv/bin/pip install -r requirements.txt; fi",
            "if [ -f pyproject.toml ]; then ./venv/bin/pip install -e .; fi",
            "# Copy systemd service file if it exists",
            "if [ -f infrastructure/systemd/crucible-platform.service ]; then",
            "  sudo cp infrastructure/systemd/crucible-platform.service /etc/systemd/system/",
            "  sudo systemctl daemon-reload",
            "fi",
            "# Restart the service",
            "sudo systemctl restart crucible-platform",
            "sleep 5",
            "sudo systemctl status crucible-platform --no-pager | head -20"
          ]' \
          --output json > command-output.json
        
        COMMAND_ID=$(jq -r '.Command.CommandId' command-output.json)
        echo "Command ID: $COMMAND_ID"
        
        # Wait for command to complete
        sleep 10
        
        # Get command output
        aws ssm get-command-invocation \
          --command-id "$COMMAND_ID" \
          --instance-id "${{ steps.ec2.outputs.instance_id }}" \
          --output json | jq -r '.StandardOutputContent'

    - name: Deployment summary
      run: |
        EC2_IP=$(aws ec2 describe-instances \
          --instance-ids "${{ steps.ec2.outputs.instance_id }}" \
          --query "Reservations[0].Instances[0].PublicIpAddress" \
          --output text)
        
        echo "âœ… Deployment complete!"
        echo ""
        echo "ðŸ“‹ Access instructions:"
        echo "1. SSH tunnel: ssh -L 8080:localhost:8080 ubuntu@${EC2_IP}"
        echo "2. Browse to: http://localhost:8080"