name: Build and Push Images

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: false
        type: string
        default: 'production'
  workflow_call:
    inputs:
      environment:
        description: 'Target environment'
        required: false
        type: string
        default: 'production'
    outputs:
      image-tag:
        description: 'The image tag (git SHA)'
        value: ${{ jobs.build.outputs.image-tag }}

env:
  AWS_REGION: ${{ vars.AWS_REGION || 'us-west-2' }}
  PROJECT_NAME: ${{ vars.PROJECT_NAME || 'crucible-platform' }}
  ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY || 'crucible-platform' }}

jobs:
  generate-specs:
    uses: ./.github/workflows/generate-openapi-spec.yml
  
  build:
    needs: generate-specs
    runs-on: ubuntu-latest
    
    outputs:
      image-tag: ${{ steps.meta.outputs.image-tag }}
    
    permissions:
      id-token: write
      contents: read
      actions: read
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set image metadata
      id: meta
      run: |
        echo "image-tag=${{ github.sha }}" >> $GITHUB_OUTPUT
    
    - name: Download OpenAPI specs
      uses: actions/download-artifact@v4
      with:
        name: openapi-specs
        path: ./
    
    - name: Configure AWS credentials via OIDC
      uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
      with:
        mask-password: 'true'
    
    - name: Build base image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ steps.meta.outputs.image-tag }}
      run: |
        docker build -t crucible-base -f shared/docker/base.Dockerfile .
        echo "âœ… Built base image"
    
    - name: Build and push all service images
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ steps.meta.outputs.image-tag }}
      run: |
        echo "ðŸ“‹ Using OpenAPI specs from generate-openapi-spec workflow"
        
        # Build and push each service
        services=(
          "nginx:nginx/Dockerfile:."
          "api:api/Dockerfile:."
          "frontend:frontend/Dockerfile:."
          "executor-service:executor-service/Dockerfile:."
          "executor-ml:docker/executor-ml/Dockerfile:."
          "celery-worker:celery-worker/Dockerfile:."
          "storage-service:storage-service/Dockerfile:."
          "storage-worker:storage-worker/Dockerfile:."
        )
        
        for service_info in "${services[@]}"; do
          IFS=':' read -r service_name dockerfile_path build_context <<< "$service_info"
          echo "ðŸ”¨ Building $service_name using $dockerfile_path from context $build_context"
          
          # Build with base image arg if it's a Python service
          if [[ "$service_name" != "nginx" && "$service_name" != "frontend" ]]; then
            docker build --build-arg BASE_IMAGE=crucible-base -f $dockerfile_path -t $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$service_name-$IMAGE_TAG $build_context
          else
            docker build -f $dockerfile_path -t $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$service_name-$IMAGE_TAG $build_context
          fi
          
          # Tag as latest and environment-specific
          docker tag $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$service_name-$IMAGE_TAG $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$service_name-latest
          docker tag $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$service_name-$IMAGE_TAG $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$service_name-${{ inputs.environment }}
          
          # Push all tags
          docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$service_name-$IMAGE_TAG
          docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$service_name-latest
          docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$service_name-${{ inputs.environment }}
          
          echo "âœ… Pushed $service_name image"
        done
    
    - name: Update SSM parameters with new images
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ steps.meta.outputs.image-tag }}
      run: |
        # Store image URLs for all services
        services=(
          "nginx"
          "api"
          "frontend"
          "executor-service"
          "executor-ml"
          "celery-worker"
          "storage-service"
          "storage-worker"
        )
        
        for service in "${services[@]}"; do
          # Store with environment prefix
          aws ssm put-parameter \
            --name "/${{ env.PROJECT_NAME }}/${{ inputs.environment }}/$service-image" \
            --value "$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$service-$IMAGE_TAG" \
            --type String \
            --overwrite
          
          # Also store without environment for backward compatibility
          if [[ "${{ inputs.environment }}" == "production" ]]; then
            aws ssm put-parameter \
              --name "/${{ env.PROJECT_NAME }}/$service-image" \
              --value "$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$service-$IMAGE_TAG" \
              --type String \
              --overwrite
          fi
          
          echo "ðŸ“ Stored $service image URL in SSM"
        done
        
        # Keep legacy parameter names for backward compatibility
        if [[ "${{ inputs.environment }}" == "production" ]]; then
          aws ssm put-parameter \
            --name "/${{ env.PROJECT_NAME }}/backend-image" \
            --value "$ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:api-$IMAGE_TAG" \
            --type String \
            --overwrite
        fi
        
        echo "âœ… Updated all SSM parameters with new images"