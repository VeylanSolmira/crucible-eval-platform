version: '3.8'

services:
  crucible-platform:
    build:
      context: .
      dockerfile: Dockerfile
    image: ${BACKEND_IMAGE:-${PROJECT_NAME:-crucible-platform}:local}
    container_name: ${CONTAINER_NAME:-crucible-platform}
    ports:
      - "8080:8080"
    volumes:
      # Mount Docker socket for sibling containers
      # Set DOCKER_SOCKET_PATH in .env file for your platform:
      # macOS: /Users/$USER/.docker/run/docker.sock
      # Linux: /var/run/docker.sock
      - ${DOCKER_SOCKET_PATH:-/var/run/docker.sock}:/var/run/docker.sock
      # Mount data directory for runtime data
      - ./data:/app/data
    environment:
      - PYTHONUNBUFFERED=1
      - DOCKER_HOST=unix:///var/run/docker.sock
      - LOG_LEVEL=INFO
      - BIND_HOST=0.0.0.0           # Bind to all interfaces in container
      - SERVICE_HOST=crucible       # Use service name for inter-container comms
      - PLATFORM_HOST=crucible      # API gateway host
      - HOST_PWD=${PWD}             # Pass host working directory for volume mapping
      - STORAGE_BASE=/app/storage   # Storage path inside container
      - FILE_STORAGE_PATH=/app/data # Runtime data storage path
      - TEMP_BASE=/app/data         # Temp directory for execution
      - DATABASE_URL=postgresql://crucible:${DB_PASSWORD:-changeme}@postgres:5432/crucible
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
    # Security options
    security_opt:
      - no-new-privileges:true
    read_only: false  # Need write for temp files, but could be true with tmpfs
    # tmpfs:
    #   - /tmp:size=100M
    
    # Previous approach for non-root Docker access (kept for reference):
    # Override user to match host's docker group (usually 999 or 998)
    # You may need to adjust this based on your system
    # Run: getent group docker | cut -d: -f3
    # to find your docker group ID
    # group_add:
    #   - "999"  # docker group - adjust if needed
    #   # If the above doesn't work, try uncommenting one of these:
    #   # - "998"  # Common on some systems
    #   # - "0"    # root group (less secure but may work)
    
    # Currently running as root for Docker socket access (see Dockerfile)

  crucible-frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        # For production behind nginx, use empty to enable relative URLs
        API_URL: ${FRONTEND_API_URL:-}
    image: ${FRONTEND_IMAGE:-${PROJECT_NAME:-crucible-platform}-frontend:local}
    container_name: ${CONTAINER_NAME:-crucible-platform}-frontend
    ports:
      - "3000:3000"
    environment:
      - API_URL=http://crucible-platform:8080
      - NODE_ENV=production
    depends_on:
      - crucible-platform
    restart: unless-stopped
    # Run as non-root user (configured in Dockerfile)

  postgres:
    image: postgres:15-alpine
    container_name: crucible-postgres
    environment:
      POSTGRES_DB: crucible
      POSTGRES_USER: crucible
      POSTGRES_PASSWORD: ${DB_PASSWORD:-changeme}
    volumes:
      - postgres-data:/var/lib/postgresql/data
    ports:
      - "5432:5432"  # For development access
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U crucible"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Database migration service - run with: docker compose run --rm migrate
  migrate:
    build: .
    image: ${BACKEND_IMAGE:-${PROJECT_NAME:-crucible-platform}:local}
    container_name: crucible-migrate
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      DATABASE_URL: postgresql://crucible:${DB_PASSWORD:-changeme}@postgres:5432/crucible
    working_dir: /app/storage/database/migrations
    entrypoint: ["alembic"]
    command: ["upgrade", "head"]
    profiles:
      - tools  # Only run when explicitly requested

  # Future: Nginx reverse proxy (currently on host)
  # nginx:
  #   image: nginx:alpine
  #   container_name: crucible-nginx
  #   ports:
  #     - "80:80"
  #     - "443:443"
  #   volumes:
  #     - ./nginx/nginx.conf:/etc/nginx/nginx.conf:ro
  #     - ./nginx/conf.d:/etc/nginx/conf.d:ro
  #     - ssl-certs:/etc/nginx/ssl:ro
  #     - acme-challenge:/var/www/html/.well-known/acme-challenge:ro
  #   depends_on:
  #     - crucible-platform
  #     - crucible-frontend
  #   restart: unless-stopped
  
  # Future: Redis for Celery (Day 3)
  # redis:
  #   image: redis:7-alpine
  #   container_name: crucible-redis
  #   volumes:
  #     - redis-data:/data
  #   restart: unless-stopped


volumes:
  # redis-data:
  postgres-data:
    driver: local
  storage:
    driver: local
  # ssl-certs:   # For containerized nginx
  # acme-challenge:  # For Let's Encrypt challenges