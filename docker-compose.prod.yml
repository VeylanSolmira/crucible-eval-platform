# Production overrides for docker-compose.yml
# Usage: docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d

services:
  # Build-only services - override to prevent build warnings in production
  # These images are built in CI/CD and not needed at runtime
  base:
    image: busybox:latest
    command: "true"
    restart: "no"
    # This is only used as a build dependency, not needed in production
  
  # executor-ml-image must NOT be overridden - it needs to use the actual ECR image
  # so that docker compose pull fetches it for the executor services to use

  # API Service with resource limits and security
  api-service:
    restart: always
    mem_limit: 256m
    memswap_limit: 256m
    cpus: 0.5
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp:size=100M,noexec,nosuid,nodev
    healthcheck:
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Celery Worker with controlled resources
  celery-worker:
    restart: always
    mem_limit: 512m
    memswap_limit: 512m
    cpus: 1.0
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp:size=200M,noexec,nosuid,nodev
    environment:
      - CELERY_WORKER_MAX_TASKS_PER_CHILD=100
      - CELERY_WORKER_PREFETCH_MULTIPLIER=4
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"

  # Storage Service with persistence
  storage-service:
    restart: always
    mem_limit: 384m
    memswap_limit: 384m
    cpus: 0.5
    # security_opt already defined in base docker-compose.yml
    volumes:
      - ./data:/app/data:rw
      - storage-db:/var/lib/postgresql/data
    healthcheck:
      interval: 10s
      timeout: 5s
      retries: 5
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Executor Services with strict limits
  executor-1:
    restart: always
    mem_limit: 256m
    memswap_limit: 256m
    cpus: 0.5
    security_opt:
      # no-new-privileges:true already in base executor config
      - seccomp:unconfined  # Needed for Docker-in-Docker
    cap_add:
      - SYS_ADMIN  # Required for container management
    devices:
      - /dev/fuse  # For some container operations
    ulimits:
      nproc: 100
      nofile:
        soft: 65536
        hard: 65536
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "5"

  executor-2:
    extends: executor-1
    
  # executor-3 disabled for t2.micro memory constraints

  # Queue Services removed - using Celery instead

  # Storage Worker with write access
  storage-worker:
    restart: always
    mem_limit: 256m
    memswap_limit: 256m
    cpus: 0.5
    security_opt:
      - no-new-privileges:true
    volumes:
      - ./data:/app/data:rw
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Frontend with caching
  crucible-frontend:
    restart: always
    mem_limit: 128m
    memswap_limit: 128m
    cpus: 0.25
    # security_opt already defined in base docker-compose.yml
    # read_only already defined in base docker-compose.yml
    tmpfs:
      - /tmp:size=100M,noexec,nosuid,nodev
      - /app/.next/cache:size=100M
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:3000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # PostgreSQL with optimizations
  postgres:
    restart: always
    mem_limit: 512m
    memswap_limit: 512m
    cpus: 1.0
    environment:
      # Performance tuning
      - POSTGRES_SHARED_BUFFERS=128MB
      - POSTGRES_EFFECTIVE_CACHE_SIZE=256MB
      - POSTGRES_MAINTENANCE_WORK_MEM=64MB
      - POSTGRES_CHECKPOINT_COMPLETION_TARGET=0.9
      - POSTGRES_WAL_BUFFERS=4MB
      - POSTGRES_DEFAULT_STATISTICS_TARGET=100
      - POSTGRES_RANDOM_PAGE_COST=1.1
      - POSTGRES_EFFECTIVE_IO_CONCURRENCY=200
    volumes:
      - postgres-data:/var/lib/postgresql/data:rw
    logging:
      driver: "json-file"
      options:
        max-size: "20m"
        max-file: "5"
    command: >
      postgres
      -c shared_preload_libraries='pg_stat_statements'
      -c pg_stat_statements.track=all
      -c log_statement='mod'
      -c log_duration=on
      -c log_min_duration_statement=100

  # Redis with persistence
  redis:
    restart: always
    mem_limit: 256m
    memswap_limit: 256m
    cpus: 0.5
    sysctls:
      - net.core.somaxconn=1024
    volumes:
      - redis-data:/data:rw
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Nginx with security headers
  nginx:
    restart: always
    mem_limit: 128m
    memswap_limit: 128m
    cpus: 0.25
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /var/cache/nginx:size=100M
      - /var/run:size=10M
    volumes:
      - /etc/nginx/ssl:/etc/nginx/ssl:ro  # Bind mount from host
      - acme-challenge:/var/www/html/.well-known/acme-challenge:ro
    environment:
      - PRODUCTION_MODE=true
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Docker proxy with minimal permissions
  docker-proxy:
    restart: always
    mem_limit: 64m
    memswap_limit: 64m
    cpus: 0.1
    security_opt:
      - no-new-privileges:true
    # Cannot use read_only: true - proxy needs to write haproxy config
    logging:
      driver: "json-file"
      options:
        max-size: "5m"
        max-file: "3"

# Production volume configurations
# Using Docker-managed volumes for better portability
volumes:
  postgres-data:
    driver: local
  
  redis-data:
    driver: local
  
  storage-db:
    driver: local

# Production network configuration
networks:
  default:
    driver: bridge
    driver_opts:
      com.docker.network.bridge.name: crucible_prod
    ipam:
      config:
        - subnet: 172.28.0.0/16