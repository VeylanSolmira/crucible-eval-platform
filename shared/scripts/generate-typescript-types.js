#!/usr/bin/env node

/**
 * Generate TypeScript types from shared YAML schemas.
 * This ensures frontend gets full type metadata (like terminal states).
 */

const fs = require('fs');
const path = require('path');
const yaml = require('js-yaml');

// Configuration: which types to generate
// Different services can have their own generation scripts with different lists
const TYPES_TO_GENERATE = [
  'evaluation-status.yaml',
  // Add more as needed:
  // 'event-contracts.yaml',
  // 'resource-limits.yaml',
];

// Paths
const SHARED_DIR = path.join(__dirname, '..');
const TYPES_DIR = path.join(SHARED_DIR, 'types');
const OUTPUT_DIR = path.join(SHARED_DIR, 'generated', 'typescript');

// Ensure output directory exists
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}

// Generate evaluation status types
function generateEvaluationStatus() {
  const yamlPath = path.join(TYPES_DIR, 'evaluation-status.yaml');
  const yamlContent = fs.readFileSync(yamlPath, 'utf8');
  const spec = yaml.load(yamlContent);
  
  const statusSchema = spec.components.schemas.EvaluationStatus;
  const enumValues = statusSchema.enum;
  
  // Extract terminal states from x-terminal-states
  let terminalStates = [];
  if (spec.components.schemas.TerminalStates?.['x-terminal-states']) {
    terminalStates = spec.components.schemas.TerminalStates['x-terminal-states'];
  }
  
  // Generate TypeScript
  let ts = `/**
 * Generated from evaluation-status.yaml
 * DO NOT EDIT THIS FILE DIRECTLY - Edit the source YAML instead
 */

export enum EvaluationStatus {
`;
  
  // Add enum values
  enumValues.forEach(value => {
    const key = value.toUpperCase().replace(/-/g, '_');
    ts += `  ${key} = '${value}',\n`;
  });
  
  ts += `}

// Terminal states - evaluations in these states will not transition further
export const TERMINAL_STATES = new Set<EvaluationStatus>([
`;
  
  terminalStates.forEach(state => {
    const key = state.toUpperCase().replace(/-/g, '_');
    ts += `  EvaluationStatus.${key},\n`;
  });
  
  ts += `]);

export function isTerminalStatus(status: EvaluationStatus | string): boolean {
  return TERMINAL_STATES.has(status as EvaluationStatus);
}

export function isActiveStatus(status: EvaluationStatus | string): boolean {
  return !isTerminalStatus(status);
}
`;
  
  // Write file
  const outputPath = path.join(OUTPUT_DIR, 'evaluation-status.ts');
  fs.writeFileSync(outputPath, ts);
  console.log(`Generated ${outputPath}`);
}

// Generate index.ts
function generateIndex() {
  const exports = [];
  
  // Add exports based on what we're generating
  if (TYPES_TO_GENERATE.includes('evaluation-status.yaml')) {
    exports.push("export * from './evaluation-status';");
  }
  // Add more exports as types are added
  
  const content = `/**
 * Generated TypeScript types from shared contracts.
 * DO NOT EDIT FILES IN THIS DIRECTORY - They are auto-generated.
 */

${exports.join('\n')}
`;
  
  const indexPath = path.join(OUTPUT_DIR, 'index.ts');
  fs.writeFileSync(indexPath, content);
  console.log(`Generated ${indexPath}`);
}

// Type generators map
const generators = {
  'evaluation-status.yaml': generateEvaluationStatus,
  // Add more generators as types are added:
  // 'event-contracts.yaml': generateEventContracts,
};

// Main
try {
  console.log('Generating TypeScript types for:', TYPES_TO_GENERATE);
  
  for (const typeFile of TYPES_TO_GENERATE) {
    const generator = generators[typeFile];
    if (generator) {
      generator();
    } else {
      console.warn(`No generator found for ${typeFile}`);
    }
  }
  
  // Generate index.ts
  generateIndex();
  
  console.log('TypeScript generation complete');
} catch (error) {
  console.error('Error generating TypeScript types:', error);
  process.exit(1);
}